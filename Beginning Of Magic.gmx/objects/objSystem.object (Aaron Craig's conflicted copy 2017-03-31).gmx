<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Globally accessible variables

//Combat Variables
globalvar inCombat, playerParty, enemyParty, playerParty0Menu, playerParty1Menu, menuLevel, party0IsFighting, party1IsFighting, party0IsDefending, party1IsDefending, partyCanMove;
inCombat = false; //For when fighting an enemy
playerParty[0] = objSara; //The party member in slot 1
playerParty[1] = objSkeletor; //The party member in slot 2 (Can be null)
playerParty[2] = null;
playerParty[3] = null;
playerParty0Menu = false; //Player Party 1's Menu is up
playerParty1Menu = false; //Player Party 2's Menu is up
menuLevel = 0; //Depth of the menu (Level 0 is off, level 1 is four main options, level 2 is choosing an option, and level 3 is then fighting or using that thing.
party0IsFighting = false; //If player is actively targeting enemy
party1IsFighting = false;
party0IsDefending = false; //Whether the player is defending
party1IsDefending = false;
partyCanMove = true; //Whether the party can move at all, turn off like in cutscene

//Non Global Combat Variables
lss = 0;
lsu = 0;
rss = 0;
rsu = 0;
stickSpeed = 3; //How quickly the sticks can move
stickSize = 1; //Size of them
enemyHitBoxSize = 25; //The size of the hit box, can be adjusted anytime
sliceLine = null; //An invisible line, gathering data when slice attack occurs
switchAT = 0; //If player has both weapon, can switch between
tempAT = "Focused"; //Use to switch weapon types in battle

globalvar sliceArray, isSliceArrayFull, sliceAttackHit;
//Array of Sliced Coordinates for attacks and magic
//sliceArray[0] = "";
isSliceArrayFull = false; //Indicating if the array is ready to be processed
sliceAttackHit = false; //Indicating if attack totally missed enemy

///Non-Combat Global Variables
globalvar isTalking, conversationCounter, shouldShowChoices, talkingObject, optionsAreAvailable, talkChoice, conversationChoices, dialogueChoices, quickMessage;
isTalking = false;
conversationCounter = 0; //Keeps track of which dialogue options will appear
shouldShowChoices = false; //If it's time to display dialogue options
talkingObject = objNPCParent; //Which NPC is currently talking
optionsAreAvailable = false;
talkChoice = 0;
quickMessage = false; //If the talking object will just show one message

//Global Menu Screen Variables
globalvar inCharacterScreen, characterScreenSelection, partySize;
inCharacterScreen = false; //In the main character screen or not
characterScreenSelection = 0; //Which character is currently selected
partySize = 2;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set Full Screen
//window_set_fullscreen(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///End dialogue, allow people to move
partyCanMove = true;
isTalking = false;
quickMessage = false;
conversationCounter = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set quick message to true
quickMessage = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Combat Overlay
if(inCombat) {
    //Level 1 Menu for PLAYER 0
    if(playerParty0Menu &amp;&amp; menuLevel == 1) {
        draw_sprite(sprDPad, 0, 64, 672);
        draw_text(96, 672, "Items");
        draw_text(64, 640, "Fight");
        if(playerParty[0].knowsMagic) //Change the text based on circumstances
            draw_text(32, 672, "Magic");
        else
        
        if(playerParty[0].canMove) //Change the text based on circumstances
            draw_text(64, 704, "Defend");
        else
            draw_text(64, 704, "Stop Defending");
        draw_sprite(playerParty[0].myAnims[3], 0, 150, 672); //Draw portrait of selecting player
    }
    //Level 2 menu for PLAYER 0
    if(playerParty0Menu &amp;&amp; menuLevel == 2 &amp;&amp; party0IsDefending) {
        draw_text(64, 704, "Press A to begin Defending");
    }
    if(playerParty0Menu &amp;&amp; menuLevel == 2 &amp;&amp; party0IsFighting &amp;&amp; playerParty[0].weaponAT == "Both") {
        draw_text(64, 704, "Press Y to alter attack type");
    }
    //Level 1 Menu for PLAYER 1
    if(playerParty1Menu &amp;&amp; menuLevel == 1) {
        draw_sprite(sprDPad, 0, 928, 672);
        draw_text(960, 672, "Items");
        draw_text(928, 640, "Fight");
        if(playerParty[1].knowsMagic)
            draw_text(896, 672, "Magic");
        else
            
        if(playerParty[1].canMove)
            draw_text(928, 704, "Defend");
        else
            draw_text(928, 704, "Stop Defending");
        draw_sprite(playerParty[1].myAnims[3], 0, 832, 672); //Draw portrait of selecting player
    }
    //Level 2 menu for PLAYER 1
    if(playerParty1Menu &amp;&amp; menuLevel == 2 &amp;&amp; party1IsDefending) {
        draw_text(64, 704, "Press A to begin Defending");
    }
    if(playerParty1Menu &amp;&amp; menuLevel == 2 &amp;&amp; party1IsFighting &amp;&amp; playerParty[1].weaponAT == "Both") {
        draw_text(64, 704, "Press Y to alter attack type");
    }
    //More In Depth Menus
    
    
    //Fighting Overlay for PARTY MEMBER 1
    if((party0IsFighting) &amp;&amp; (playerParty[0].weaponAT == "Focused" || playerParty[0].tempAT == "Focused")) { //FOCUSED ATTACK
        //Gather enemy Info
        enemy = instance_nearest(lss, lsu, objEnemyParent);
        enemyBoxBot = instance_nearest(lss, lsu, objEnemyParent).bbox_bottom;
        enemyBoxTop = instance_nearest(lss, lsu, objEnemyParent).bbox_top;
        enemyBoxLeft = instance_nearest(lss, lsu, objEnemyParent).bbox_left;
        enemyBoxRight = instance_nearest(lss, lsu, objEnemyParent).bbox_right;
        //Set it so Party cannot move
        partyCanMove = false;
        //Controller Vibration
        gamepad_set_vibration(0, (lsu/enemyBoxLeft - .4), (rsu/enemyBoxRight - .4)); //Grows as the circles get closer to the enemy (-.25 to make it not rattle too strongly)
        
        //Draw the left stick
        lss += gamepad_axis_value(0, gp_axislh) * stickSpeed + random_range(-.75, .75); //Left Stick Sideways (random range makes it more difficult, can be adjusted based on level/wind/difficulty)
        lsu += gamepad_axis_value(0, gp_axislv) * stickSpeed + random_range(-.75, .75);//Left Stick Up
        if(!instance_exists(objLeftStick)) {
            leftStick = instance_create(playerParty[0].x, playerParty[0].y, objLeftStick);
            leftStick.image_alpha = .5; //Set it fairly transparent
            lss = playerParty[0].x;
            lsu = playerParty[0].y;
        }
        leftStick.x = lss;
        leftStick.y = lsu;
        
        //Then the right stick
        rss += gamepad_axis_value(0, gp_axisrh)* stickSpeed + random_range(-.75, .75); //Right Stick Sideways 
        rsu += gamepad_axis_value(0, gp_axisrv)* stickSpeed + random_range(-.75, .75); //Right Stick Up
        if(!instance_exists(objRightStick)) {
            rightStick = instance_create(playerParty[0].x, playerParty[0].y, objRightStick);
            rightStick.image_alpha = .5;
            rss = playerParty[0].x;
            rsu = playerParty[0].y;
        }
        rightStick.x = rss;
        rightStick.y = rsu;
        
        //Decrease Stick size over time to a certain degree
        if(stickSize &gt; .5)
            stickSize -= .0005;
        rightStick.image_xscale = stickSize;
        rightStick.image_yscale = stickSize;
        leftStick.image_xscale = stickSize;
        leftStick.image_yscale = stickSize;

        //Check to see if sticks are over enemy
        //if(((lss &gt; enemyBoxTop &amp;&amp; lss &lt; enemyBoxBot) &amp;&amp; (lsu &gt; enemyBoxLeft &amp;&amp; lsu &lt; enemyBoxRight)) &amp;&amp; ((rss &gt; enemyBoxTop &amp;&amp; rss &lt; enemyBoxBot) &amp;&amp; (rsu &gt; enemyBoxLeft &amp;&amp; rsu &lt; enemyBoxRight)))  {
                if(gamepad_button_check(0, gp_shoulderlb) &amp;&amp; gamepad_button_check(0, gp_shoulderrb)) { //Pull both triggers to attack
                    //Play the animation of player shooting bow
                    playerParty[0].image_index = playerParty[0].myAnims[4];
                    playerParty[0].image_speed = .01;
                    if(!collision_point(leftStick.x, leftStick.y, objRightStick, false, false)) { //Since their aim is off, decrease overall attack damage
                        playerParty[0].hasBadAim = true;
                    }
                   //Calculate if the attack hit a criticle spot on the enemy
                   for(i = 0; i &lt; array_length_1d(enemy.myGrid); ++i) { //Begin looping through the entire 2D array
                        for(j = 0; j &lt; array_height_2d(enemy.myGrid); ++j) {
                            if(enemy.myGrid[i, j] != null) { //Only check spots that aren't null
                                critSpotRight = enemyBoxLeft + ((i + 1) * enemyHitBoxSize);
                                critSpotLeft = enemyBoxLeft + (i * enemyHitBoxSize);
                                critSpotTop = enemyBoxTop + (j * enemyHitBoxSize);
                                critSpotBottom = enemyBoxTop + ((j + 1) * enemyHitBoxSize);
                                if(((lss &gt; critSpotLeft &amp;&amp; lss &lt; critSpotRight) &amp;&amp; (lsu &gt; critSpotTop &amp;&amp; lsu &lt; critSpotBottom) &amp;&amp; (rss &gt; critSpotLeft &amp;&amp; rss &lt; critSpotRight) &amp;&amp; rsu &gt; critSpotTop &amp;&amp; rsu &lt; critSpotBottom)) {
                                    playerParty[0].empoweredAttack = true;
                                }
                            }
                        }
                   }
                   //Deal damage, reset everything
                   if(collision_circle(leftStick.x, leftStick.y, 5, objEnemyParent, false, false)) //Only deal damage if at least 1 stick is over enemy
                        scrEvalDamage(playerParty[0], enemy);
                   gamepad_set_vibration(0, 0, 0);
                   partyCanMove = true;
                   menuLevel = 0;
                   party0IsFighting = false;
                   playerParty[0].empoweredAttack = false;
                   stickSize = 1;
                   playerParty0Menu = false;
                   //Destroy sticks
                   with(rightStick)
                        instance_destroy();
                   with(leftStick)
                        instance_destroy();
            }
        }
    //}
    else if((party0IsFighting) &amp;&amp; (playerParty[0].weaponAT == "Slice" || playerParty[0].tempAT == "Slice")) { //SLICE ATTACK
        //Gather enemy location data
        enemy = instance_nearest(lss, lsu, objEnemyParent);
        enemyBoxBot = instance_nearest(lss, lsu, objEnemyParent).bbox_bottom;
        enemyBoxTop = instance_nearest(lss, lsu, objEnemyParent).bbox_top;
        enemyBoxLeft = instance_nearest(lss, lsu, objEnemyParent).bbox_left;
        enemyBoxRight = instance_nearest(lss, lsu, objEnemyParent).bbox_right;
        //Set it so Party cannot move
        partyCanMove = false;
        
        gamepad_set_vibration(0, (lsu/enemyBoxLeft - .4), (rsu/enemyBoxRight - .4));
        
        //Draw the left stick
        lss += gamepad_axis_value(0, gp_axislh) * stickSpeed + random_range(-.75, .75); //Left Stick Sideways
        lsu += gamepad_axis_value(0, gp_axislv) * stickSpeed + random_range(-.75, .75); //Left Stick Up
        if(!instance_exists(objLeftStick)) {
            leftStick = instance_create(50, 50, objLeftStick);
            leftStick.image_alpha = .5;
            lss = playerParty[0].x;
            lsu = playerParty[0].y;
        }
        leftStick.x = lss;
        leftStick.y = lsu;
        
        //Then the right stick
        rss += gamepad_axis_value(0, gp_axisrh)* stickSpeed + random_range(-.75, .75); //Right Stick Sideways
        rsu += gamepad_axis_value(0, gp_axisrv)* stickSpeed + random_range(-.75, .75); //Right Stick Up
        if(!instance_exists(objRightStick)) {
            rightStick = instance_create(50, 50, objRightStick);
            rightStick.image_alpha = .5;
            rss = playerParty[0].x;
            rsu = playerParty[0].y;
        }
        rightStick.x = rss;
        rightStick.y = rsu;
        
        //Draw a line between the two sticks, to indicate a slice
        draw_line(rightStick.x, rightStick.y, leftStick.x, leftStick.y);
        if(rightStick.y &gt; leftStick.y)
            lineLength = abs(rightStick.x - leftStick.x) + (rightStick.y - leftStick.y);
        else
            lineLength = abs(leftStick.x - rightStick.x) + (leftStick.y - rightStick.y);
        
        //Creates a slice that gathers all of the co-ordinates that the attack will pass though
        if(gamepad_button_check(0, gp_shoulderlb) &amp;&amp; gamepad_button_check(0, gp_shoulderrb) &amp;&amp; sliceLine == null) {
            //Will need to play an animation here to buy time to do math
            sliceLine = instance_create(rightStick.x, rightStick.y, objSliceLine);
            sliceLine.moveToX = leftStick.x;
            sliceLine.moveToY = leftStick.y;
            with(sliceLine)
                move_towards_point(moveToX, moveToY, 5);
        }
        //Calculatue if slice attack hits any vital parts and then do damage
        if(isSliceArrayFull) {
            //Calculate if the attack hit a criticle spot on the enemy
            for(i = 0; i &lt; array_length_1d(enemy.myGrid); ++i) { //Begin looping through the entire 2D array
                for(j = 0; j &lt; array_height_2d(enemy.myGrid); ++j) {
                    if(enemy.myGrid[i, j] != null) { //Only check spots that aren't null
                        for(k = 0; k &lt; array_height_2d(sliceArray); ++k) {
                            critSpotRight = enemyBoxLeft + ((i + 1) * enemyHitBoxSize);
                            critSpotLeft = enemyBoxLeft + (i * enemyHitBoxSize);
                            critSpotTop = enemyBoxTop + (j * enemyHitBoxSize);
                            critSpotBottom = enemyBoxTop + ((j + 1) * enemyHitBoxSize);
                            critSpotX = (critSpotRight - enemyHitBoxSize/2);
                            critSpotY = (critSpotTop - enemyHitBoxSize/2);
                            if(abs(critSpotX - sliceArray[k,0]) &lt; enemyHitBoxSize/2 &amp;&amp; (abs(critSpotY - sliceArray[k,1]) &lt; enemyHitBoxSize/2)) {
                                playerParty[0].empoweredAttack = true;
                            }
                        }
                    }
                }
           }
           if(sliceAttackHit) { //Only deal damage if the slice hit in the first place
                scrEvalDamage(playerParty[0], enemy);
           }
            //Reset slice array
            isSliceArrayFull = false;
            gamepad_set_vibration(0, 0, 0);
            partyCanMove = true;
            menuLevel = 0;
            party0IsFighting = false;
            playerParty[0].empoweredAttack = false;
            stickSize = 1;
            sliceAttackHit = false;
            playerParty0Menu = false;
            //Destroy sticks
            with(rightStick)
                 instance_destroy();
            with(leftStick)
                 instance_destroy();
        }
    }
    //Fighting Overlay for PARTY MEMBER 2
    if((party1IsFighting) &amp;&amp; (playerParty[1].weaponAT == "Focused" || playerParty[1].tempAT == "Focused")) { //FOCUSED ATTACK
        //Gather enemy Info
        enemy = instance_nearest(lss, lsu, objEnemyParent);
        enemyBoxBot = instance_nearest(lss, lsu, objEnemyParent).bbox_bottom;
        enemyBoxTop = instance_nearest(lss, lsu, objEnemyParent).bbox_top;
        enemyBoxLeft = instance_nearest(lss, lsu, objEnemyParent).bbox_left;
        enemyBoxRight = instance_nearest(lss, lsu, objEnemyParent).bbox_right;
        //Set it so Party cannot move
        partyCanMove = false;
        //Controller Vibration
        gamepad_set_vibration(0, (lsu/enemyBoxLeft - .4), (rsu/enemyBoxRight - .4)); //Grows as the circles get closer to the enemy (-.25 to make it not rattle too strongly)
        
        //Draw the left stick
        lss += gamepad_axis_value(0, gp_axislh) * stickSpeed + random_range(-.75, .75); //Left Stick Sideways (random range makes it more difficult, can be adjusted based on level/wind/difficulty)
        lsu += gamepad_axis_value(0, gp_axislv) * stickSpeed + random_range(-.75, .75);//Left Stick Up
        if(!instance_exists(objLeftStick)) {
            leftStick = instance_create(playerParty[1].x, playerParty[1].y, objLeftStick);
            leftStick.image_alpha = .5; //Set it fairly transparent
            lss = playerParty[1].x;
            lsu = playerParty[1].y;
        }
        leftStick.x = lss;
        leftStick.y = lsu;
        
        //Then the right stick
        rss += gamepad_axis_value(0, gp_axisrh)* stickSpeed + random_range(-.75, .75); //Right Stick Sideways 
        rsu += gamepad_axis_value(0, gp_axisrv)* stickSpeed + random_range(-.75, .75); //Right Stick Up
        if(!instance_exists(objRightStick)) {
            rightStick = instance_create(playerParty[1].x, playerParty[1].y, objRightStick);
            rightStick.image_alpha = .5;
            rss = playerParty[1].x;
            rsu = playerParty[1].y;
        }
        rightStick.x = rss;
        rightStick.y = rsu;
        
        //Decrease Stick size over time to a certain degree
        if(stickSize &gt; .5)
            stickSize -= .0005;
        rightStick.image_xscale = stickSize;
        rightStick.image_yscale = stickSize;
        leftStick.image_xscale = stickSize;
        leftStick.image_yscale = stickSize;

        //Check to see if sticks are over enemy
        //if(((lss &gt; enemyBoxTop &amp;&amp; lss &lt; enemyBoxBot) &amp;&amp; (lsu &gt; enemyBoxLeft &amp;&amp; lsu &lt; enemyBoxRight)) &amp;&amp; ((rss &gt; enemyBoxTop &amp;&amp; rss &lt; enemyBoxBot) &amp;&amp; (rsu &gt; enemyBoxLeft &amp;&amp; rsu &lt; enemyBoxRight)))  {
                if(gamepad_button_check(0, gp_shoulderlb) &amp;&amp; gamepad_button_check(0, gp_shoulderrb)) { //Pull both triggers to attack
                   if(!collision_point(leftStick.x, leftStick.y, objRightStick, false, false)) { //Since their aim is off, decrease overall attack damage
                        playerParty[1].hasBadAim = true;
                    }
                   //Calculate if the attack hit a criticle spot on the enemy
                   for(i = 0; i &lt; array_length_1d(enemy.myGrid); ++i) { //Begin looping through the entire 2D array
                        for(j = 0; j &lt; array_height_2d(enemy.myGrid); ++j) {
                            if(enemy.myGrid[i, j] != null) { //Only check spots that aren't null
                                critSpotRight = enemyBoxLeft + ((i + 1) * enemyHitBoxSize);
                                critSpotLeft = enemyBoxLeft + (i * enemyHitBoxSize);
                                critSpotTop = enemyBoxTop + (j * enemyHitBoxSize);
                                critSpotBottom = enemyBoxTop + ((j + 1) * enemyHitBoxSize);
                                if(((lss &gt; critSpotLeft &amp;&amp; lss &lt; critSpotRight) &amp;&amp; (lsu &gt; critSpotTop &amp;&amp; lsu &lt; critSpotBottom) &amp;&amp; (rss &gt; critSpotLeft &amp;&amp; rss &lt; critSpotRight) &amp;&amp; rsu &gt; critSpotTop &amp;&amp; rsu &lt; critSpotBottom)) {
                                    playerParty[1].empoweredAttack = true;
                                }
                            }
                        }
                   }
                   //Deal damage, reset everything
                   if(collision_circle(leftStick.x, leftStick.y, 5, objEnemyParent, false, false)) //Only deal damage if at least 1 stick is over enemy
                        scrEvalDamage(playerParty[1], enemy);
                   gamepad_set_vibration(0, 0, 0);
                   partyCanMove = true;
                   menuLevel = 0;
                   party1IsFighting = false;
                   playerParty[1].empoweredAttack = false;
                   stickSize = 1;
                   playerParty1Menu = false;
                   //Destroy sticks
                   with(rightStick)
                        instance_destroy();
                   with(leftStick)
                        instance_destroy();
            }
        }
    //}
    else if((party1IsFighting) &amp;&amp; (playerParty[1].weaponAT == "Slice" || playerParty[1].tempAT == "Slice")) { //SLICE ATTACK
        //Gather enemy location data
        enemy = instance_nearest(lss, lsu, objEnemyParent);
        enemyBoxBot = instance_nearest(lss, lsu, objEnemyParent).bbox_bottom;
        enemyBoxTop = instance_nearest(lss, lsu, objEnemyParent).bbox_top;
        enemyBoxLeft = instance_nearest(lss, lsu, objEnemyParent).bbox_left;
        enemyBoxRight = instance_nearest(lss, lsu, objEnemyParent).bbox_right;
        //Set it so Party cannot move
        partyCanMove = false;
        
        //Draw the left stick
        lss += gamepad_axis_value(0, gp_axislh) * stickSpeed + random_range(-.75, .75); //Left Stick Sideways
        lsu += gamepad_axis_value(0, gp_axislv) * stickSpeed + random_range(-.75, .75); //Left Stick Up
        if(!instance_exists(objLeftStick)) {
            leftStick = instance_create(50, 50, objLeftStick);
            leftStick.image_alpha = .5;
            lss = playerParty[1].x;
            lsu = playerParty[1].y;
        }
        leftStick.x = lss;
        leftStick.y = lsu;
        
        //Then the right stick
        rss += gamepad_axis_value(0, gp_axisrh)* stickSpeed + random_range(-.75, .75); //Right Stick Sideways
        rsu += gamepad_axis_value(0, gp_axisrv)* stickSpeed + random_range(-.75, .75); //Right Stick Up
        if(!instance_exists(objRightStick)) {
            rightStick = instance_create(50, 50, objRightStick);
            rightStick.image_alpha = .5;
            rss = playerParty[1].x;
            rsu = playerParty[1].y;
        }
        rightStick.x = rss;
        rightStick.y = rsu;
        
        gamepad_set_vibration(0, (lsu/enemyBoxLeft - .4), (rsu/enemyBoxRight - .4));
        
        //Draw a line between the two sticks, to indicate a slice
        draw_line(rightStick.x, rightStick.y, leftStick.x, leftStick.y);
        if(rightStick.y &gt; leftStick.y)
            lineLength = abs(rightStick.x - leftStick.x) + (rightStick.y - leftStick.y);
        else
            lineLength = abs(leftStick.x - rightStick.x) + (leftStick.y - rightStick.y);
        
        //Creates a slice that gathers all of the co-ordinates that the attack will pass though
        if(gamepad_button_check(0, gp_shoulderlb) &amp;&amp; gamepad_button_check(0, gp_shoulderrb) &amp;&amp; sliceLine == null) {
            //Will need to play an animation here to buy time to do math
            sliceLine = instance_create(rightStick.x, rightStick.y, objSliceLine);
            sliceLine.moveToX = leftStick.x;
            sliceLine.moveToY = leftStick.y;
            with(sliceLine)
                move_towards_point(moveToX, moveToY, 5);
        }
        //Calculatue if slice attack hits any vital parts and then do damage
        if(isSliceArrayFull) {
            //Calculate if the attack hit a criticle spot on the enemy
            for(i = 0; i &lt; array_length_1d(enemy.myGrid); ++i) { //Begin looping through the entire 2D array
                for(j = 0; j &lt; array_height_2d(enemy.myGrid); ++j) {
                    if(enemy.myGrid[i, j] != null) { //Only check spots that aren't null
                        for(k = 0; k &lt; array_height_2d(sliceArray); ++k) {
                            critSpotRight = enemyBoxLeft + ((i + 1) * enemyHitBoxSize);
                            critSpotLeft = enemyBoxLeft + (i * enemyHitBoxSize);
                            critSpotTop = enemyBoxTop + (j * enemyHitBoxSize);
                            critSpotBottom = enemyBoxTop + ((j + 1) * enemyHitBoxSize);
                            critSpotX = (critSpotRight - enemyHitBoxSize/2);
                            critSpotY = (critSpotTop - enemyHitBoxSize/2);
                            if(abs(critSpotX - sliceArray[k,0]) &lt; enemyHitBoxSize/2 &amp;&amp; (abs(critSpotY - sliceArray[k,1]) &lt; enemyHitBoxSize/2)) {
                                playerParty[1].empoweredAttack = true;
                            }
                        }
                    }
                }
           }
           if(sliceAttackHit) { //Only deal damage if the slice hit in the first place
                scrEvalDamage(playerParty[1], enemy);
           }
            //Reset slice array
            isSliceArrayFull = false;
            gamepad_set_vibration(0, 0, 0);
            partyCanMove = true;
            menuLevel = 0;
            party1IsFighting = false;
            playerParty[1].empoweredAttack = false;
            stickSize = 1;
            sliceAttackHit = false;
            playerParty1Menu = false;
            //Destroy sticks
            with(rightStick)
                 instance_destroy();
            with(leftStick)
                 instance_destroy();
        }
    }
    
    //Health Overlays
    if(playerParty[0] != null) { //Player 0 Health
        draw_text(15, 15, playerParty[0].firstName + "'s Health: " + string(playerParty[0].currentHealth));
    }
    if(playerParty[1] != null) { //Player 1 Health
       draw_text(15, 30, playerParty[1].firstName + "'s Health: " + string(playerParty[1].currentHealth)); 
    }
    if(instance_number(objEnemyParent) &gt; 0) { //All enemies health
        //Gather all enemies into an array
        for(i = 0; i &lt; instance_number(objEnemyParent); ++i) {
            enemyList[i] = instance_find(objEnemyParent, i);
        }
        //Display each enemy still in the array
        for(i = 0; i &lt; instance_number(objEnemyParent); ++i) {
            //Be sure that they still exist, since it's in combat
            if(instance_exists(enemyList[i])) {
                draw_text(750, 15 + (i * 15), enemyList[i].name + "'s Current Health: " + string(enemyList[i].currentHealth));
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dialogue System

//Make options visible
if(shouldShowChoices) {
    //Create all the options, and later on make them visible
    dialogueChoices[0] = instance_create(view_xview[view_current] + (view_hborder[view_current] - 200), view_yview[view_current] + (1.3* view_vborder[view_current]), objDialogueChoice);
    dialogueChoices[1] = instance_create(view_xview[view_current] + (view_hborder[view_current] + 200), view_yview[view_current] + (1.3* view_vborder[view_current]), objDialogueChoice);
    dialogueChoices[2] = instance_create(view_xview[view_current] + (view_hborder[view_current] - 200), view_yview[view_current] + (1.7* view_vborder[view_current]), objDialogueChoice);
    dialogueChoices[3] = instance_create(view_xview[view_current] + (view_hborder[view_current] + 200), view_yview[view_current] + (1.7* view_vborder[view_current]), objDialogueChoice);
    //Give the choices text to display later on
    for(i = 1; i &lt; array_length_2d(talkingObject.myDialogue, conversationCounter); ++i) {
        dialogueChoices[i - 1].myText = string_delete(talkingObject.myDialogue[conversationCounter, i], 1, 1);
        dialogueChoices[i - 1].visible = true;
    }
    //Delete text box
    with(instance_find(objDialogueBox, 0)) {
        instance_destroy();
    }
    //Move onto selecting options
    shouldShowChoices = false;
    optionsAreAvailable = true;
}

//Select different dialogue choices
if(isTalking &amp;&amp; optionsAreAvailable) {
    if(talkChoice == 0 &amp;&amp; gamepad_button_check_pressed(0, gp_padr)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 1;
    }
    else if(talkChoice == 0 &amp;&amp; gamepad_button_check_pressed(0, gp_padd)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 2;
    }
    else if(talkChoice == 1 &amp;&amp; gamepad_button_check_pressed(0, gp_padd)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 3;
    }
    else if(talkChoice == 1 &amp;&amp; gamepad_button_check_pressed(0, gp_padl)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 0;
    }
    else if(talkChoice == 2 &amp;&amp; gamepad_button_check_pressed(0, gp_padu)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 0;
    }
    else if(talkChoice == 2 &amp;&amp; gamepad_button_check_pressed(0, gp_padr)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 3;
    }
    else if(talkChoice == 3 &amp;&amp; gamepad_button_check_pressed(0, gp_padl)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 2;
    }
    else if(talkChoice == 3 &amp;&amp; gamepad_button_check_pressed(0, gp_padu)) {
        dialogueChoices[talkChoice].image_index = 0;
        talkChoice = 1;
    }
    dialogueChoices[talkChoice].image_index = 1;
}
//While talking, act on their selection
if(isTalking &amp;&amp; optionsAreAvailable &amp;&amp; gamepad_button_check_pressed(0, gp_face1)) {
    conversationCounter = real(string_char_at(talkingObject.myDialogue[conversationCounter, talkChoice + 1], 0));
    //show_message(conversationCounter);
    talkChoice = 0;
    //Check to see if the conversation is over
    if(array_length_2d(talkingObject.myDialogue, conversationCounter) == 0 || conversationCounter == 0) { //End talk immediately since NPC has nothing left to say 
        alarm[1] = 10;
        for(i = 0; i &lt; array_length_1d(dialogueChoices); ++i) {
            with(dialogueChoices[i])
                instance_destroy();
        }
        talkingObject.iAmTalking = false;
    }
    else if(array_length_2d(talkingObject.myDialogue, conversationCounter) == 1) { //Show last message from NPC
        talkChoice = 0;
        alarm[0] = 3;
        //talkingObject.isTalking = false;
        scrShowOneText(talkingObject);
    }
    else { //If continueing the conversation
        scrStartDialogue(playerParty[0], talkingObject);
    }
    for(i = 0; i &lt; array_length_1d(dialogueChoices); ++i) {
        with(dialogueChoices[i])
            instance_destroy();
    }
    optionsAreAvailable = false;
}

//Quick Message
if(quickMessage &amp;&amp; gamepad_button_check_pressed(0, gp_face1)) {
    with(instance_find(objDialogueBox, 0))
        instance_destroy();
    alarm[1] = 10;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
