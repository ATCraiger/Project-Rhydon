<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Variables
wobbleRange[0] = 1; //Easy
wobbleRange[1] = 1.5;
wobbleRange[2] = 2;
wobbleRange[3] = 2.5;
wobbleRange[4] = 3; //Very Hard

currentWobble = wobbleRange[0];

stickMoveSpeed = 3;

xDest = 0;
yDest = 0;

sentBy = undefined; //Who lauched the attack
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//////COMBAT TEST ONLY/////
beatMonster = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cooldown for attacks
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Menu Selection
leftStickHoriz = gamepad_axis_value(0, gp_axislh);
leftStickVert = gamepad_axis_value(0, gp_axislv);
rightStickHoriz = gamepad_axis_value(0, gp_axisrh);
rightStickVert = gamepad_axis_value(0, gp_axisrv);

///////////EVERYTHING FOR PLAYERPARTY[0]/////////////
if(gamepad_button_check_pressed(0, gp_shoulderlb) &amp;&amp; playerParty[0].menuLevel == 0 &amp;&amp; playerParty[1].isInMenu == false &amp;&amp; alarm[0] &lt; 1) //Only allow 1 menu at a time
{
    playerParty[0].isInMenu = true;
    ++playerParty[0].menuLevel;
}
if(gamepad_button_check_pressed(0, gp_face2) &amp;&amp; playerParty[0].isInMenu == true) { //Go back after making a selection
    --playerParty[0].menuLevel;
    playerParty[0].menuLevel = clamp(playerParty[0].menuLevel, 0, 3);
    if(playerParty[0].menuLevel == 0) //Reset the boolean for party 1
        playerParty[0].isInMenu = false;
    if(playerParty[0].isFighting) { //Reset fighting Conditions
        playerParty[0].isFighting = false;
        playerParty[0].canMove = true;
        partyCanMove = true;
        //stickSize = 1; //Not sure what this does
        gamepad_set_vibration(0, 0, 0);
        if(instance_exists(objLeftStick) &amp;&amp; instance_exists(objRightStick)) { //Delete the sticks if they're backing out of combat
            leftStick = instance_find(objLeftStick, 0);
            with(leftStick)
                instance_destroy();
            rightStick = instance_find(objRightStick, 0);
            with(rightStick)
                instance_destroy();
        }
    }
}
//First level of menu choices
if(playerParty[0].isInMenu &amp;&amp; playerParty[0].menuLevel == 1) {
    if(gamepad_button_check_pressed(0, gp_padu) &amp;&amp; playerParty[0].currentStamina &gt;= playerParty[0].attackCost) { //Choosing Up on the D-Pad //Fight
        ++playerParty[0].menuLevel;
        playerParty[0].isFighting = true;
        playerParty[0].isDefending = false;
        partyCanMove = false;
        playerParty[0].canMove = false;
    }
    if(gamepad_button_check_pressed(0, gp_padr)) { //Choosing Right on the D-Pad //DEFEND
        
    }
    if(gamepad_button_check_pressed(0, gp_padl)) { //Choosing Left on the D-Pad //MAGIC
        
    }
    if(gamepad_button_check_pressed(0, gp_padd)) { //Choosing Down on the D-Pad //ITEMS
    
    }
    if(gamepad_button_check_pressed(0, gp_padd) &amp;&amp; !playerParty[0].canMove) { //STOP defending
        playerParty[0].menuLevel = 0;
        playerParty[0].isDefending = false;
        playerParty[0].canMove = true;
        playerParty[0].isInMenu = false;
    }
}
//Fighting
if(playerParty[0].isFighting) {
    if(instance_exists(objLeftStick)) {
        gamepad_set_vibration(0, .25, .25);
        with(objLeftStick)
            show_debug_message(-distance_to_point(objEnemyParent.x, objEnemyParent.y) / 1000 )
        //Controlled by the player
        leftStick.x += (leftStickHoriz * stickMoveSpeed);
        leftStick.y += (leftStickVert * stickMoveSpeed);
        rightStick.x += (rightStickHoriz * stickMoveSpeed);
        rightStick.y += (rightStickVert * stickMoveSpeed);
        //Adding in some wobble
        leftStick.x += random_range(0, currentWobble);
        leftStick.x -= random_range(0, currentWobble);
        leftStick.y += random_range(0, currentWobble);
        leftStick.y -= random_range(0, currentWobble);
        rightStick.x += random_range(0, currentWobble);
        rightStick.x -= random_range(0, currentWobble);
        rightStick.y += random_range(0, currentWobble);
        rightStick.y -= random_range(0, currentWobble);
    }
    else {
        randomNumber = irandom_range(0, 1);
        if(randomNumber == 0)
            leftX = -irandom_range(0, 100);
        else
            leftX = irandom_range(0, 100)
        randomNumber = irandom_range(0, 1);
        if(randomNumber == 0)
            leftY = -irandom_range(0, 100)
        else
            leftY = irandom_range(0, 100)
        randomNumber = irandom_range(0, 1);
        if(randomNumber == 0)
            rightX = -irandom_range(0, 100)
        else
            rightX = irandom_range(0, 100)
        if(randomNumber == 0)
            rightY = -irandom_range(0, 100)
        else
            rightY = irandom_range(0, 100)
        leftStick = instance_create(playerParty[0].x + leftX, playerParty[0].y + leftY, objLeftStick);
        rightStick = instance_create(playerParty[0].x + rightX, playerParty[0].y + rightY, objRightStick);
    }
    //Firing at the enemy
    if(gamepad_button_check(0, gp_shoulderlb) &amp;&amp; gamepad_button_check(0, gp_shoulderrb)) {
        alarm[0] = 20; //A cooldown, so that after the attack, the other player isn't auto selected into menu
        sentBy = playerParty[0];
        //Pick the spot between the two sticks that attack is going towards
        xDest = random_range(leftStick.x, rightStick.x);
        yDest = random_range(leftStick.y, rightStick.y);
        attack = instance_create(playerParty[0].x, playerParty[0].y, objTestFighter);
        //Return to default states
        playerParty[0].isFighting = false;
        playerParty[0].menuLevel = 0;
        playerParty[0].isInMenu = false;
        playerParty[0].canMove = true;
        partyCanMove = true;
        
        with(leftStick)
            instance_destroy();
        with(rightStick)
            instance_destroy();
            
        gamepad_set_vibration(0,0,0);
        playerParty[0].currentStamina -= playerParty[0].attackCost;
    }
}
//Second Level of menu choices
if(playerParty[0].isInMenu &amp;&amp; playerParty[0].menuLevel == 2) {
    if(gamepad_button_check_pressed(0, gp_face1) &amp;&amp; playerParty[0].isDefending) { //Choosing to begin defending
        playerParty[0].menuLevel = 0;
        playerParty[0].isDefending = true;
        playerParty[0].canMove = false;
        playerParty[0].isInMenu = false;
    }
    if(playerParty[0].isFighting &amp;&amp; playerParty[0].weaponAT == "Both" &amp;&amp; gamepad_button_check_pressed(0, gp_face4)) { //Switch between attack types
        if(playerParty[0].tempAT == "Slice")
            playerParty[0].tempAT = "Focused";
        else if(playerParty[0].tempAT == "Focused")
            playerParty[0].tempAT = "Slice";
    }
}
/////////////EVERYTHIGN FOR PLAYERPARTY[1] //// MUST BE CHANGED SO THAT IT ISN'T A COPY OF THE CODE
if(gamepad_button_check_pressed(0, gp_shoulderrb) &amp;&amp; playerParty[1].menuLevel == 0 &amp;&amp; playerParty[0].isInMenu == false &amp;&amp; alarm[0] &lt; 1) //Only allow 1 menu at a time
{
    playerParty[1].isInMenu = true;
    ++playerParty[1].menuLevel;
}
if(gamepad_button_check_pressed(0, gp_face2) &amp;&amp; playerParty[1].isInMenu == true) { //Go back after making a selection
    --playerParty[1].menuLevel;
    playerParty[1].menuLevel = clamp(playerParty[1].menuLevel, 0, 3);
    if(playerParty[1].menuLevel == 0) //Reset the boolean for party 1
        playerParty[1].isInMenu = false;
    if(playerParty[1].isFighting) { //Reset fighting Conditions
        playerParty[1].isFighting = false;
        playerParty[1].canMove = true;
        partyCanMove = true;
        //stickSize = 1; //Not sure what this does
        gamepad_set_vibration(0, 0, 0);
        if(instance_exists(objLeftStick) &amp;&amp; instance_exists(objRightStick)) { //Delete the sticks if they're backing out of combat
            leftStick = instance_find(objLeftStick, 0);
            with(leftStick)
                instance_destroy();
            rightStick = instance_find(objRightStick, 0);
            with(rightStick)
                instance_destroy();
        }
    }
}
//First level of menu choices
if(playerParty[1].isInMenu &amp;&amp; playerParty[1].menuLevel == 1) {
    if(gamepad_button_check_pressed(0, gp_padu) &amp;&amp; playerParty[1].currentStamina &gt;= playerParty[1].attackCost) { //Choosing Up on the D-Pad //Fight
        ++playerParty[1].menuLevel;
        playerParty[1].isFighting = true;
        playerParty[1].isDefending = false;
        partyCanMove = false;
        playerParty[1].canMove = false;
    }
    if(gamepad_button_check_pressed(0, gp_padr)) { //Choosing Right on the D-Pad //DEFEND
        
    }
    if(gamepad_button_check_pressed(0, gp_padl)) { //Choosing Left on the D-Pad //MAGIC
        
    }
    if(gamepad_button_check_pressed(0, gp_padd)) { //Choosing Down on the D-Pad //ITEMS
    
    }
    if(gamepad_button_check_pressed(0, gp_padd) &amp;&amp; !playerParty[1].canMove) { //STOP defending
        playerParty[1].menuLevel = 0;
        playerParty[1].isDefending = false;
        playerParty[1].canMove = true;
        playerParty[1].isInMenu = false;
    }
}
//Fighting
if(playerParty[1].isFighting) {
    if(instance_exists(objLeftStick)) {
        gamepad_set_vibration(0, .25, .25);
        with(objLeftStick)
            show_debug_message(-distance_to_point(objEnemyParent.x, objEnemyParent.y) / 1000 )
        //Controlled by the player
        leftStick.x += (leftStickHoriz * stickMoveSpeed);
        leftStick.y += (leftStickVert * stickMoveSpeed);
        rightStick.x += (rightStickHoriz * stickMoveSpeed);
        rightStick.y += (rightStickVert * stickMoveSpeed);
        //Adding in some wobble
        leftStick.x += random_range(0, currentWobble);
        leftStick.x -= random_range(0, currentWobble);
        leftStick.y += random_range(0, currentWobble);
        leftStick.y -= random_range(0, currentWobble);
        rightStick.x += random_range(0, currentWobble);
        rightStick.x -= random_range(0, currentWobble);
        rightStick.y += random_range(0, currentWobble);
        rightStick.y -= random_range(0, currentWobble);
    }
    else {
        randomNumber = irandom_range(0, 1);
        if(randomNumber == 0)
            leftX = -irandom_range(0, 100);
        else
            leftX = irandom_range(0, 100)
        randomNumber = irandom_range(0, 1);
        if(randomNumber == 0)
            leftY = -irandom_range(0, 100)
        else
            leftY = irandom_range(0, 100)
        randomNumber = irandom_range(0, 1);
        if(randomNumber == 0)
            rightX = -irandom_range(0, 100)
        else
            rightX = irandom_range(0, 100)
        if(randomNumber == 0)
            rightY = -irandom_range(0, 100)
        else
            rightY = irandom_range(0, 100)
        leftStick = instance_create(playerParty[1].x + leftX, playerParty[1].y + leftY, objLeftStick);
        rightStick = instance_create(playerParty[1].x + rightX, playerParty[1].y + rightY, objRightStick);
    }
    //Firing at the enemy
    if(gamepad_button_check(0, gp_shoulderlb) &amp;&amp; gamepad_button_check(0, gp_shoulderrb)) {
        alarm[0] = 20;
        sentBy = playerParty[1];
        //Pick the spot between the two sticks that attack is going towards
        xDest = random_range(leftStick.x, rightStick.x);
        yDest = random_range(leftStick.y, rightStick.y);
        attack = instance_create(playerParty[1].x, playerParty[1].y, objTestFighter);
        //Return to default states
        playerParty[1].isFighting = false;
        playerParty[1].menuLevel = 0;
        playerParty[1].isInMenu = false;
        playerParty[1].canMove = true;
        partyCanMove = true;
        
        with(leftStick)
            instance_destroy();
        with(rightStick)
            instance_destroy();
            
        gamepad_set_vibration(0,0,0);
        playerParty[1].currentStamina -= playerParty[1].attackCost;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////When battle is over TESTING
if(!instance_exists(objEnemyParent) &amp;&amp; beatMonster) {
    show_message("Thanks for play testing! I hope you enjoyed it. Please give me your feedback");
    game_end();
}

if(beatMonster == false &amp;&amp; !instance_exists(objEnemyParent) ) {
    playerParty[0].x = 400;
    playerParty[0].y = 400;
    playerParty[1].x = 400;
    playerParty[1].y = 500;
    show_message("Now, you can see the hit boxes. Red for crits, blue for hit, pink for miss");
    instance_create(700, 700, objTestEnemy);
    beatMonster = true;
}

if(beatMonster) {
    for(i = 0; i &lt; instance_number(objMonsterHitBox); ++i) {
        box = instance_find(objMonsterHitBox, i);
        box.visible = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
